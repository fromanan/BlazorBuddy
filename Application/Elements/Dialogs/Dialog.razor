<dialog id="@Id">
    @* ReSharper disable once Html.AttributeValueNotResolved *@
    <form id="@Id-form" method="dialog">
        <div id="@Id-header" class="dialog-header flex-parent">
            <legend class="flex-child-text">@Title</legend>
            <FlexSpacer/>
            <IconButton IconOnly="@true" Class="dialog-close"/>
        </div>
        <div id="@Id-body" class="dialog-body flex-parent">
            @BodyContent
        </div>
        <div id="@Id-footer" class="dialog-footer flex-parent">
            @FooterContent
        </div>
    </form>
</dialog>

@code
{
    [Inject]
    private IJSRuntime JsRuntime { get; set; } = null!;
    
    [Parameter]
    public required string Id { get; set; }
    
    [Parameter]
    public required string Title { get; set; }
    
    [Parameter]
    public RenderFragment? BodyContent { get; set; }
    
    [Parameter]
    public RenderFragment? FooterContent { get; set; }

    private DialogElement _dialogElement = null!;

    private Action<bool, object?>? ModalResultCallback { get; set; }
    
    // TODO: Create timeout for modals

    private CancellationTokenSource _tokenSource = new();

    private TaskCompletionSource<bool> _completionSource = new();

    protected override void OnInitialized()
    {
        _dialogElement = new DialogElement(JsRuntime, Id);
    }

    public async Task<bool> OpenModalAsync(Action<bool, object?>? callback = null)
    {
        _completionSource = new TaskCompletionSource<bool>(_tokenSource);

        await _dialogElement.OpenDialog();
        
        ModalResultCallback = _AsyncCallback;
        
        await InvokeAsync(StateHasChanged);
        
        return await _completionSource.Task;

        async void _AsyncCallback(bool success, object? result)
        {
            if (!success)
            {
                _completionSource.TrySetCanceled(_tokenSource.Token);
            }
            else
            {
                _completionSource.TrySetResult(success);
            }
            
            if (ModalResultCallback is not null)
            {
                await Task.Run(() => callback?.Invoke(success, result ?? (success ? GetDialogResult() : null)));
            }
            
            LayoutService.ShowOverlay();
        }
    }
    
    public void OpenModal(Action<bool, object?>? callback = null)
    {
        ModalResultCallback = callback;
        
        InvokeAsync(StateHasChanged);
        
        LayoutService.ShowOverlay();
    }

    // Passing result lets us manually override a result, if needed by a handler
    protected async Task CloseModal(bool success = false, object? result = null)
    {
        await _dialogElement.CloseDialog();

        if (ModalResultCallback is not null)
        {
            await Task.Run(() => ModalResultCallback?.Invoke(success, result ?? (success ? GetDialogResult() : null)));
        }
        
        await InvokeAsync(StateHasChanged);
        
        LayoutService.HideOverlay();
    }

    protected async Task CancelDialog()
    {
        await CloseModal();
    }

    protected virtual object? GetDialogResult()
    {
        return null;
    }

    protected virtual async Task OnKeyDown(KeyboardEventArgs args)
    {
        switch (args.Key)
        {
            case KeyCode.Enter:
            case KeyCode.Accept:
                await CloseModal(true);
                break;
            case KeyCode.Escape:
            case KeyCode.Cancel:
                await CancelDialog();
                break;
        }
    }
}